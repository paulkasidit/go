"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TravelTimeProtoClient = void 0;
/* eslint-disable class-methods-use-this */
const axios_1 = __importDefault(require("axios"));
const protobufjs_1 = __importDefault(require("protobufjs"));
const rateLimiter_1 = require("./rateLimiter");
class TravelTimeProtoClient {
    constructor(credentials, parameters) {
        this.baseUri = 'http://proto.api.traveltimeapp.com/api/v2';
        this.protoDistanceUri = 'https://proto-with-distance.api.traveltimeapp.com/api/v2';
        this.protoFileDir = `${__dirname}/proto/v2`;
        this.transportationMap = {
            pt: 0,
            'driving+ferry': 3,
            'cycling+ferry': 6,
            'walking+ferry': 7,
        };
        this.timeFilterFast = (request) => __awaiter(this, void 0, void 0, function* () {
            return this.readProtoFile()
                .then((root) => __awaiter(this, void 0, void 0, function* () { return this.handleProtoFile(root, this.baseUri, request); }));
        });
        this.timeFilterFastDistance = (request) => __awaiter(this, void 0, void 0, function* () {
            return this.readProtoFile()
                .then((root) => __awaiter(this, void 0, void 0, function* () { return this.handleProtoFile(root, this.protoDistanceUri, request, { useDistance: true }); }));
        });
        this.setRateLimitSettings = (settings) => {
            this.setRateLimitSettings(settings);
        };
        if (!(credentials.applicationId && credentials.apiKey))
            throw new Error('Credentials must be valid');
        this.applicationId = credentials.applicationId;
        this.apiKey = credentials.apiKey;
        this.rateLimiter = new rateLimiter_1.RateLimiter(parameters === null || parameters === void 0 ? void 0 : parameters.rateLimitSettings);
        this.axiosInstance = axios_1.default.create({
            auth: {
                username: this.applicationId,
                password: this.apiKey,
            },
            headers: {
                'Content-Type': 'application/octet-stream',
                Accept: 'application/octet-stream',
                'User-Agent': 'Travel Time Nodejs SDK',
            },
            responseType: 'arraybuffer',
        });
    }
    encodeFixedPoint(sourcePoint, targetPoint) {
        return Math.round((targetPoint - sourcePoint) * (10 ** 5));
    }
    buildRequestUrl(uri, { country, transportation }) {
        return `${uri}/${country}/time-filter/fast/${transportation}`;
    }
    buildDeltas(departure, destinations) {
        return destinations.flatMap((destination) => [this.encodeFixedPoint(departure.lat, destination.lat), this.encodeFixedPoint(departure.lng, destination.lng)]);
    }
    buildProtoRequest({ departureLocation, destinationCoordinates, transportation, travelTime, }, options) {
        if (!(transportation in this.transportationMap)) {
            throw new Error('Transportation type is not supported');
        }
        return {
            oneToManyRequest: {
                departureLocation,
                locationDeltas: this.buildDeltas(departureLocation, destinationCoordinates),
                transportation: {
                    type: this.transportationMap[transportation],
                },
                arrivalTimePeriod: 0,
                travelTime,
                properties: (options === null || options === void 0 ? void 0 : options.useDistance) ? [1] : undefined,
            },
        };
    }
    readProtoFile() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield protobufjs_1.default.load([
                    `${this.protoFileDir}/TimeFilterFastRequest.proto`,
                    `${this.protoFileDir}/TimeFilterFastResponse.proto`,
                ]);
            }
            catch (_a) {
                throw new Error(`Could not load proto file at: ${this.protoFileDir}`);
            }
        });
    }
    handleProtoFile(root, uri, request, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const TimeFilterFastRequest = root.lookupType('com.igeolise.traveltime.rabbitmq.requests.TimeFilterFastRequest');
            const TimeFilterFastResponse = root.lookupType('com.igeolise.traveltime.rabbitmq.responses.TimeFilterFastResponse');
            const messageRequest = this.buildProtoRequest(request, options);
            const message = TimeFilterFastRequest.create(messageRequest);
            const buffer = TimeFilterFastRequest.encode(message).finish();
            const rq = () => this.axiosInstance.post(this.buildRequestUrl(uri, request), buffer);
            try {
                const promise = this.rateLimiter.isEnabled() ? new Promise((resolve) => {
                    this.rateLimiter.addAndExecute(() => resolve(rq()), 1);
                }) : rq();
                const { data } = yield promise;
                const response = TimeFilterFastResponse.decode(data);
                return response.toJSON();
            }
            catch (e) {
                throw new Error('Error while sending proto request');
            }
        });
    }
}
exports.TravelTimeProtoClient = TravelTimeProtoClient;
