"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TravelTimeClient = void 0;
const axios_1 = __importDefault(require("axios"));
const error_1 = require("../error");
const rateLimiter_1 = require("./rateLimiter");
const DEFAULT_BASE_URL = 'https://api.traveltimeapp.com/v4';
function getHitAmountFromRequest(url, body) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    switch (url) {
        case '/time-filter':
        case '/routes':
        case '/time-filter/postcode-districts':
        case '/time-filter/postcode-sectors':
        case '/time-filter/postcodes': {
            return (((_a = body.departure_searches) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = body.arrival_searches) === null || _b === void 0 ? void 0 : _b.length) || 0);
        }
        case '/time-map/fast':
        case '/time-filter/fast': {
            return (((_c = body.arrival_searches.one_to_many) === null || _c === void 0 ? void 0 : _c.length) || 0) + (((_d = body.arrival_searches.many_to_one) === null || _d === void 0 ? void 0 : _d.length) || 0);
        }
        case '/time-map': {
            return (((_e = body.departure_searches) === null || _e === void 0 ? void 0 : _e.length) || 0) + (((_f = body.arrival_searches) === null || _f === void 0 ? void 0 : _f.length) || 0) + (((_g = body.unions) === null || _g === void 0 ? void 0 : _g.length) || 0) + (((_h = body.intersections) === null || _h === void 0 ? void 0 : _h.length) || 0);
        }
        default: return 0;
    }
}
function endpointChecksHPM(url) {
    return [
        '/time-filter',
        '/routes',
        '/time-filter/postcode-districts',
        '/time-filter/postcode-sectors',
        '/time-filter/postcodes',
        '/time-map/fast',
        '/time-filter/fast',
        '/time-map',
    ].includes(url);
}
class TravelTimeClient {
    constructor(credentials, parameters) {
        var _a;
        this.mapInfo = () => __awaiter(this, void 0, void 0, function* () { return this.request('/map-info', 'get'); });
        this.routes = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/routes', 'post', { body }); });
        this.supportedLocations = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/supported-locations', 'post', { body }); });
        this.timeFilter = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/time-filter', 'post', { body }); });
        this.timeFilterFast = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/time-filter/fast', 'post', { body }); });
        this.timeFilterPostcodeDistricts = (body) => __awaiter(this, void 0, void 0, function* () {
            return this
                .request('/time-filter/postcode-districts', 'post', { body });
        });
        this.timeFilterPostcodeSectors = (body) => __awaiter(this, void 0, void 0, function* () {
            return this
                .request('/time-filter/postcode-sectors', 'post', { body });
        });
        this.timeFilterPostcodes = (body) => __awaiter(this, void 0, void 0, function* () { return this.request('/time-filter/postcodes', 'post', { body }); });
        this.getBaseURL = () => this.axiosInstance.defaults.baseURL;
        /**
         *
         * @param baseURL Set new base URL. Pass nothing to reset to default
         */
        this.setBaseURL = (baseURL = DEFAULT_BASE_URL) => {
            this.axiosInstance.defaults.baseURL = baseURL;
        };
        this.setRateLimitSettings = (settings) => {
            this.setRateLimitSettings(settings);
        };
        if (!(credentials.applicationId && credentials.apiKey))
            throw new Error('Credentials must be valid');
        this.applicationId = credentials.applicationId;
        this.apiKey = credentials.apiKey;
        this.rateLimiter = new rateLimiter_1.RateLimiter(parameters === null || parameters === void 0 ? void 0 : parameters.rateLimitSettings);
        this.axiosInstance = axios_1.default.create({
            baseURL: (_a = parameters === null || parameters === void 0 ? void 0 : parameters.baseURL) !== null && _a !== void 0 ? _a : DEFAULT_BASE_URL,
            headers: {
                'Content-Type': 'application/json',
                'X-Application-Id': this.applicationId,
                'X-Api-Key': this.apiKey,
                'User-Agent': 'Travel Time Nodejs SDK',
            },
        });
    }
    request(url, method, payload, retryCount = 0) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { body, config } = payload || {};
            const rq = () => (method === 'get' ? this.axiosInstance[method](url, config) : this.axiosInstance[method](url, body, config));
            try {
                const promise = (this.rateLimiter.isEnabled() && endpointChecksHPM(url)) ? new Promise((resolve) => {
                    this.rateLimiter.addAndExecute(() => resolve(rq()), getHitAmountFromRequest(url, body || {}));
                }) : rq();
                const { data } = yield promise;
                return data;
            }
            catch (error) {
                if (this.rateLimiter.isEnabled() && retryCount < 3 && axios_1.default.isAxiosError(error) && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 429) {
                    return this.request(url, method, payload, retryCount + 1);
                }
                throw error_1.TravelTimeError.makeError(error);
            }
        });
    }
    geocoding(query, req) {
        return __awaiter(this, void 0, void 0, function* () {
            const { acceptLanguage, params } = req || {};
            const headers = acceptLanguage ? { 'Accept-Language': acceptLanguage } : undefined;
            const bounds = (params === null || params === void 0 ? void 0 : params.bounds) ? `${params.bounds.southEast.lat},${params.bounds.southEast.lng},${params.bounds.northWest.lat},${params.bounds.northWest.lng}` : undefined;
            const withinCountry = Array.isArray(params === null || params === void 0 ? void 0 : params['within.country']) ? params === null || params === void 0 ? void 0 : params['within.country'].join(',') : params === null || params === void 0 ? void 0 : params['within.country'];
            return this.request('/geocoding/search', 'get', {
                config: {
                    params: Object.assign(Object.assign({}, params), { 'within.country': withinCountry, bounds, query }),
                    headers,
                },
            });
        });
    }
    geocodingReverse(coords, acceptLanguage) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = acceptLanguage ? { 'Accept-Language': acceptLanguage } : undefined;
            return this.request('/geocoding/reverse', 'get', { config: { params: coords, headers } });
        });
    }
    timeMap(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = format ? { Accept: format } : undefined;
            return this.request('/time-map', 'post', { body, config: { headers } });
        });
    }
    timeMapFast(body, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = format ? { Accept: format } : undefined;
            return this.request('/time-map/fast', 'post', { body, config: { headers } });
        });
    }
}
exports.TravelTimeClient = TravelTimeClient;
